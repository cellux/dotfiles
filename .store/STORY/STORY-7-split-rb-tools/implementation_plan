1. Add dedicated modules for each responsibility: `rb-tools-eval.el` hosts truthiness plus Clojure/Elisp/Bash evaluation helpers, `rb-tools-ts.el` contains Tree-sitter parsing, node validation, insertion/update helpers, and their regression tests, `rb-tools-io.el` keeps line-range, regex, and read/write utilities with their tests, and `rb-tools-store.el` houses JSON schema handling plus the object store implementation and its tests.
2. Relocate each function (and the ERT coverage that exercises it) into the appropriate module, ensuring each file declares the libraries it needs, `provide`s itself, and moves shared `defvar`s (e.g. the Tree-sitter language map, formatting hook, IO hooks) to a place where the other modules can reference them.
3. Keep `rb-tools.el` as the thin entry point that requires the new modules, reâ€‘exports or references the symbols needed for the GPTel tools and presets, and wires together the tool definitions so downstream consumers see no behavioral change.
4. After the split, run the relevant test group inside each module file (evaluation, Tree-sitter, IO, store) and verify the GPTel tool definitions still point at the relocated functions via the aggregator.